#Morguhn Burke
#mcb196
#4/18/2022
#CS-4379-D Assignment 4

#This assignment was coded by me using python in Microsoft visual studio code.
#It is an event based simulation making use of a linked list implimentation of a priority queue based on event arrival time (Node.py) (Line: 441)

#This program generates events in two different stages, firstly, it determines if a new player/miner is to be added/removed
#from the simulation based on a number created from a geometric distribtion of probability 0.1 (Line: 234, 365, 431) 
#Then, if the current event time has surpassed the previous time + the next time generated by geometric distribution, a player/miner will be added/removed

#Following this, any active players (Defined in Players.py) will have transaction events generated (Deposit, withdrawl, Transfer, Hold) (Events.py)
#After all the events are processed, they are assigned to the miner who's block they were assigned to in a Blockchain with a sha256 cryptographic has (BlockChain.py)


import time
import random
import csv
import pandas as pd
import numpy as np
import Players as P
import BlockChain as BC
import Node as N
import Events as ev


playerList = []

class Miner(P.Players):
    def __init__(self, name):
        self.name = name
        self.head = None
        self.role = "Miner"
        self.playersAdded = False
        self.numPlayersAdded = 0
        self.addedPlayers = []
        self.nodeData = []
        self.requestStatus = []
        self.blockChain = None
        self.chainDelta = 0
        
    def writeEvents(events, MasterPlayerList, MasterMinerList):
        #Name ActionCode PaymentMethod PaymentAmount (TransferTarget IF Transfer)
        newEventList = []
        for evt in events:
            try:
                player = evt.player
                event = " "
                if evt.actionCode == 9:
                    print("Standard Error: " + str(player.name) + " was not assigned an action code. Player forced to Hold")
                    evt.actionCode = 3
                    event = (str(player.name) + " " + str(evt.actionCode))
                elif evt.actionCode == 0: #Deposit Deposits go to E
                    event = (str(player.name) + " " + str(evt.actionCode) + " " + str(evt.paymentMethod) + " " + str(evt.paymentAmt) + " " + str(evt.minerTarget) + " " + str(evt.arrivalTime))
                elif evt.actionCode == 1: #Withdrawl from E
                    event = (str(player.name) + " " + str(evt.actionCode) + " " + str(evt.paymentMethod) + " " + str(evt.withdrawlAmt) + " " + str(evt.minerTarget)+ " " + str(evt.arrivalTime))
                elif evt.actionCode == 2: #Transfer funds to player
                    event = (str(player.name) + " " + str(evt.actionCode) + " " + str(evt.paymentMethod) + " " + str(evt.transferAmt) + " " + str(evt.transferTarget)+ " " + str(evt.arrivalTime))

                newEventList.append(event)
            
            except AttributeError:
                None
            
            newEventList = list(filter((' ').__ne__, newEventList))
            newEventList = list(filter(('').__ne__, newEventList))
        
        return newEventList
    
    def removeDuplicates(input):
        res = []
        [res.append(x) for x in input if x not in res]
        return res
    
    def getCurrPlayer(name, playerList):
        for player in playerList:
            if name == player.name:
                currPlayer = player
        try:        
            return currPlayer
        except UnboundLocalError:
            print("Event Error Occured, player: " + str(name))
            return A
        
    def getMinerTarget(n, minerList):
        for miner in minerList:
            if miner.name == n:
                return miner
            
        return E
    
    def executeEvents(playerList, minerList, eventQueue):
        
        print("executing")
        currEvent = eventQueue
        while currEvent.next != None:
            event = currEvent.data
            event = event.split(' ')
            if event[1] == '0':
                Miner.handleDeposit(currEvent, minerList)
            elif event[1] == '1':
                Miner.handleWithdrawl(currEvent, minerList)
            elif event[1] == '2':
                Miner.handleTransfer(currEvent, playerList)
            else:
                print("There was an unknown error with an event: ")
                print(event)
            currEvent = currEvent.next
        
    def handleDeposit(event, minerList):
        
        acceptedTransaction = True
        event = event.data
        event = event.split(' ')
        currPlayer = Miner.getCurrPlayer(event[0], playerList)
        paymentMethod = event[2]
        paymentAmt = int(event[3])
        currMiner = Miner.getMinerTarget(event[4], minerList)
        
        if paymentMethod == "Account":
            if currPlayer.acctBal - paymentAmt >= 0:
                string = "Account Deposit approved from " + str(currPlayer.name) + " in the amount of: " + str(paymentAmt)
                currPlayer.acctBal -= paymentAmt
                currPlayer.chainBalance += paymentAmt
                currPlayer.approvedCnt += 1
                currMiner.chainDelta += paymentAmt
            else:
                string = "Account Deposit Denied from " + str(currPlayer.name) + " due to lack of funds"
                acceptedTransaction = False
                currPlayer.deniedCnt += 1
                
        if paymentMethod == "Credit":
            if currPlayer.creditBalance + paymentAmt <= currPlayer.creditLimit:
                string = "Credit Deposit approved from " + str(currPlayer.name) + " in the amount of: " + str(paymentAmt)
                currPlayer.creditBalance -= paymentAmt
                currPlayer.chainBalance += paymentAmt
                currPlayer.approvedCnt += 1
                currMiner.chainDelta += paymentAmt
                
            else:
                string = "Credit Deposit Denied from " + str(currPlayer.name) + " due to lack of funds"
                acceptedTransaction = False
                currPlayer.deniedCnt += 1
                
        Miner.updateStatus(event, string, currMiner, acceptedTransaction)
        
    def handleWithdrawl(event, minerList):
        
        acceptedTransaction = True
        event = event.data
        event = event.split(' ')
        currPlayer = Miner.getCurrPlayer(event[0], playerList)
        paymentMethod = event[2]
        paymentAmt = int(event[3])
        currMiner = Miner.getMinerTarget(event[4], minerList)
        
        if paymentAmt == 0:
            string = "Account Withdrawl Denied from " + str(currPlayer.name) + " due to lack of funds"
            acceptedTransaction = False
            currPlayer.deniedCnt += 1
        else:
            if paymentMethod == "Account":
                if currPlayer.chainBalance - paymentAmt >= 0:
                    string = "Account Withdrawl approved from " + str(currPlayer.name) + " in the amount of: " + str(paymentAmt)
                    currPlayer.acctBal += paymentAmt
                    currPlayer.approvedCnt += 1
                    currPlayer.chainBalance -= paymentAmt
                    currMiner.chainDelta  -= paymentAmt
                else:
                    string = "Account Withdrawl Denied from " + str(currPlayer.name) + " due to lack of funds"
                    acceptedTransaction = False
                    currPlayer.deniedCnt += 1
                    
        if paymentMethod == "Credit":
            if currPlayer.chainBalance - paymentAmt >= 0:
                string = "Credit Withdrawl approved from " + str(currPlayer.name) + " in the amount of: " + str(paymentAmt)
                currPlayer.approvedCnt += 1
                currPlayer.chainBalance -= paymentAmt
                currMiner.chainDelta -= paymentAmt  
                currPlayer.creditBalance -= paymentAmt
                if currPlayer.creditBalance< 0: #if credit balance goes negative, add the remainder to account
                    leftovers = abs(currPlayer.creditBalance)
                    currPlayer.creditBalance += leftovers
                    currPlayer.acctBal += leftovers
            else:
                    string = "Account Withdrawl Denied from " + str(currPlayer.name) + " due to lack of funds"
                    acceptedTransaction = False
                    currPlayer.deniedCnt += 1
                    
        Miner.updateStatus(event, string, currMiner, acceptedTransaction)
        
    def handleTransfer(event, playerList):
        acceptedTransaction = True
        event = event.data
        event = event.split(' ')
        currPlayer = Miner.getCurrPlayer(event[0], playerList)
        paymentMethod = event[2]
        transferAmt = int(event[3])
        transferTarget = Miner.getCurrPlayer(event[4], playerList)
        
        if paymentMethod == "Account":
            if currPlayer.acctBal - transferAmt >= 0:
                string = "Account Transfer Between " + str(currPlayer.name) + " and " + str(transferTarget.name) + " was Approved: " + str(currPlayer.transferAmt)
                currPlayer.acctBal -= transferAmt
                transferTarget.acctBal += transferAmt
                currPlayer.approvedCnt += 1
            else:
                string = "Account Transfer Between " + str(currPlayer.name) + " and " + str(transferTarget.name) + " was Denied"
                acceptedTransaction = False
                currPlayer.deniedCnt += 1
                
        if paymentMethod == "Credit":
            if currPlayer.creditBalance + transferAmt <= currPlayer.creditLimit:
                string = "Credit Transfer Between " + str(currPlayer.name) + " and " + str(transferTarget.name) + " was Approved: " + str(transferAmt)
                currPlayer.creditBalance += transferAmt
                transferTarget.acctBal += transferAmt
                currPlayer.approvedCnt += 1
            else:
                string = "Credit Transfer Between " + str(currPlayer.name) + " and " + str(transferTarget.name) + " was Denied"
                acceptedTransaction = False
                currPlayer.deniedCnt += 1
        
        Miner.updateStatus(event, string, E, acceptedTransaction)
            
    def updateStatus(currEvent, string, currMiner, acceptedTransaction):
        if(acceptedTransaction):
            if currEvent not in currMiner.nodeData:
                    currMiner.nodeData.append(currEvent)
            
        if string not in E.requestStatus:
            E.requestStatus.append(string)        
        
    def getEventTime():
        time = np.random.geometric(p=0.1, size = 1)
        time = time/1000
        return time
    
    def getRole():
        role = np.random.choice(["Player", "Miner"], replace = False, p = [0.5, 0.5])
        return role
    
    def rollName(nameOptions):
        name = np.random.choice(["F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"])
        return name
    
    def pickPlayerToRemove():
        toRemove = random.choice(E.addedPlayers)

        return toRemove
    
    def removeFromList(player, playerList):
        for item in playerList:
            if player.name == item.name:
                playerList.remove(item)
        return playerList
    
    def getBlockClusterssss(miner):
        nodeData = miner.nodeData
        miner.nodeData = []
        cluster = []
        i = 0
        clusterSize = random.randint(1,6) #maximum of 6 items ber block
        while i < len(nodeData):
            if i == clusterSize:
                clusterSize += random.randint(1,7) #randint is uninclusive on upper bound
                miner.nodeData.append(cluster)
                cluster = []
            else:
                cluster.append(nodeData[i])
            i += 1
    
    def getBlockClusters(miner):
        nodeData = miner.nodeData
        miner.nodeData = []
        cluster = []
        addedToCluster = []
        skipped = []
        i = 0
        clusterSize = random.randint(1,7) #maximum of 6 items ber block
        while i < len(nodeData):
            if i == clusterSize:
                clusterSize += random.randint(1,7) #randint is uninclusive on upper bound
                miner.nodeData.append(cluster)
                cluster = []
                addedToCluster = []
            else:
                if nodeData[i][0] not in addedToCluster:
                    cluster.append(nodeData[i])
                    addedToCluster.append(nodeData[i][0])
                else:
                    skipped.append(nodeData[i])
            i += 1
                 
        while len(skipped) > 0:
            i = 0
            if len(skipped) == 1:
                nodeData.append(skipped[0])
                skipped.pop(i)
                break
            clusterSize = random.randint(1,7)
            while i < len(skipped):
                if i == clusterSize:
                    clusterSize += random.randint(1,7) #randint is uninclusive on upper bound
                    miner.nodeData.append(cluster)
                    cluster = []
                    addedToCluster = []
                else:
                    if str(nodeData[i][0]) not in addedToCluster:
                        cluster.append(nodeData[i])
                        addedToCluster.append(str(nodeData[i][0]))
                        skipped.pop(i)
                    else:
                        None
                i += 1
                      
#################################################################

def getStatistics(MasterPlayerList, elapsedTime):
    totalEvents = 0
    approvedEvents =0
    deniedEvents = 0
    
    for player in MasterPlayerList:
        approvedEvents += player.approvedCnt
        deniedEvents += player.deniedCnt
        totalEvents += (player.approvedCnt + player.deniedCnt)
    
    avgApproved = approvedEvents/totalEvents
    avgDenied = deniedEvents/totalEvents
    
    print("End Statistics:")
    print("Total Events: " + str(totalEvents))
    print("Number Approved Events: " + str(approvedEvents))
    print("Number Denied Events: " + str(deniedEvents))
    print("Average Events Approved: " + str(round(100*avgApproved,2))+"%")
    print("Average Events Denied: " + str(round(100*avgDenied,2))+"%")
    print("Total Events Per Second: " + str(round(totalEvents/elapsedTime,2)))
    print("Approved Events Per Second: " + str(round(approvedEvents/elapsedTime,2)))
    print("Denied Events Per Second: " + str(round(deniedEvents/elapsedTime,2)))
    
    
#Generate Events on timed loop, writing to file
def generateEvents(A, B, C, D, E):
    startTime = time.time()
    runTime = 5
    previousTime = 0
    
    eventQueue = None
    events = []
    
    global playerList
    playerList = [A, B, C, D]
    
    minerList = [E]
    MasterPlayerList = [A, B, C, D] #A list of all players that ever existed in the simulation NEVER removed from
    MasterMinerList = [E]
    nameOptions = ['F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

    print('Generating Events...')
    while True: #Timed Loop
        currTime = time.time()
        elapsed_time = currTime - startTime
        
        nextTime = Miner.getEventTime()
        if len(nameOptions) > 0:
            #Players have been added
            if E.playersAdded == True:
                if E.numPlayersAdded < 2 and elapsed_time >= previousTime + nextTime: 
                        name = random.choice(nameOptions)
                        role = Miner.getRole()
                        nameOptions.remove(str(name))
                        if role == "Player":          
                            eventLimit = P.Players.getEventLimit()
                            acctBal = P.Players.getAcctBal()
                            creditLimit = P.Players.getCreditLim(acctBal)        
                            newPlayer = P.Players(name, eventLimit, acctBal, creditLimit)
                            playerList.append(newPlayer)
                            MasterPlayerList.append(newPlayer)
                        if role == "Miner":
                            newPlayer = Miner(name)
                            minerList.append(newPlayer)
                            MasterMinerList.append(newPlayer)
                        E.numPlayersAdded += 1
                        E.addedPlayers.append(newPlayer)
                if E.numPlayersAdded > 0 and elapsed_time >= previousTime + nextTime:
                    E.addedPlayers.remove(random.choice(E.addedPlayers))
                    E.numPlayersAdded -= 1
                    if E.numPlayersAdded == 0:
                        E.playersAdded = False
                    
            #Players have not been added
            if E.playersAdded == False:
                if elapsed_time >= previousTime + nextTime: 
                    name = random.choice(nameOptions)
                    role = Miner.getRole()
                    nameOptions.remove(str(name))
                    if role == "Player":          
                        eventLimit = P.Players.getEventLimit()
                        acctBal = P.Players.getAcctBal()
                        creditLimit = P.Players.getCreditLim(acctBal)        
                        newPlayer = P.Players(name, eventLimit, acctBal, creditLimit)
                        playerList.append(newPlayer)
                        MasterPlayerList.append(newPlayer)
                    if role == "Miner":
                        newPlayer = Miner(name)
                        minerList.append(newPlayer)
                        MasterMinerList.append(newPlayer)
                    E.numPlayersAdded += 1
                    E.addedPlayers.append(newPlayer)
                    E.playersAdded = True
                    
        #Generate an event:
        for player in playerList:
            newEvent = ev.Events(player)
            newEvent.actionCode = ev.Events.rollActionCode(newEvent)
            newEvent.paymentMethod = ev.Events.getPaymentMethod()
            if newEvent.actionCode == 0 or newEvent.actionCode == 1: #Deposits or withdrawls
                newEvent.minerTarget = ev.Events.getMinerTarget(minerList)
                if newEvent.actionCode == 0:
                    newEvent.paymentAmt = ev.Events.getPaymentAmt(newEvent)
                if newEvent.actionCode == 1:
                    newEvent.withdrawlAmt = ev.Events.getWithdrawlAmt(newEvent.player)
            if newEvent.actionCode == 2: #Transfers
                newEvent.transferTarget = ev.Events.getTransferTarget(newEvent.player)
                newEvent.transferAmt = ev.Events.getPaymentAmt(newEvent)
            newEvent.arrivalTime = elapsed_time
            #temporary event list
            events.append(newEvent)
        
        previousTime = elapsed_time    
            
        if elapsed_time > runTime:
            print("Ceased generating events after " + str(elapsed_time) + " seconds without issue.")
            break
            
    #Filter Bad Events
    events = Miner.writeEvents(events, MasterPlayerList, MasterMinerList)
            
    #Create Priority Event Queue
    eventQueue = N.Node.buildLinkedList(events)
    #Write Events to File
    
    events = [x for x in events if x] #Filters out empty list components (Where holds used to be)
    df = pd.DataFrame(events)
    df.to_csv('transactionRequests.csv', encoding='utf-8', index=False) #Randomly generated transaction requests
    
    print(" Event Requests Logged")
    print(" Executing Events")
    Miner.executeEvents(MasterPlayerList, MasterMinerList, eventQueue)
    df = pd.DataFrame(E.requestStatus)
    df.to_csv('transactionStatus.csv', encoding='utf-8', index=False) #Banks approval or denial of requsts
    
    print(" Getting blocks")
    i = 1
    for miner in MasterMinerList:
        Miner.getBlockClusters(miner)
        i += 1

    print("Generating Blockchains")
    for miner in MasterMinerList:
        if len(miner.nodeData) > 0:
            miner.blockChain = BC.Blockchain()
            for i in range(1,len(miner.nodeData)):
                string = str(miner.nodeData[i])
                string = string.replace("'","")
                if string != "[]":
                    miner.blockChain.create_block_from_transaction(string)
            #miner.blockChain.display_chain()
            miner.blockChain.write_to_file(miner.name)
            
    P.Players.printPlayerInfo(MasterPlayerList)
    
    getStatistics(MasterPlayerList, elapsed_time)
    
#############################################################
#Establish Players
#A
eventLimit = P.Players.getEventLimit()
acctBal = P.Players.getAcctBal()
creditLimit = P.Players.getCreditLim(acctBal)
A = P.Players("A",eventLimit, acctBal, creditLimit)

#B
eventLimit = P.Players.getEventLimit()
acctBal = P.Players.getAcctBal()
creditLimit = P.Players.getCreditLim(acctBal) 
B = P.Players("B", eventLimit, acctBal, creditLimit)

#C
eventLimit = P.Players.getEventLimit()
acctBal = P.Players.getAcctBal()
creditLimit = P.Players.getCreditLim(acctBal)
C = P.Players("C", eventLimit, acctBal, creditLimit)

#D
eventLimit = P.Players.getEventLimit()
acctBal = P.Players.getAcctBal()
creditLimit = P.Players.getCreditLim(acctBal)
D = P.Players("D", eventLimit, acctBal, creditLimit)

#Establish Miner
#E
E = Miner("E")

generateEvents(A, B, C, D, E)